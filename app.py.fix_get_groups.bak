# app.py ‚Äî resilient single-client Mongo + Flask app for HUDDLE
import os
import sys
import traceback
import re
from datetime import datetime

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from pymongo import MongoClient
from bson.objectid import ObjectId
import bcrypt
from dotenv import load_dotenv

# Load .env if present (do NOT commit .env)
load_dotenv()

# ==================== FLASK APP INIT ====================
app = Flask(__name__, static_folder=".", static_url_path="")
# Allow all origins during development; set a stricter origin in production via env
CORS(app, resources={r"/*": {"origins": os.environ.get("CORS_ORIGINS", "*")}})

# ==================== MONGO CONNECTION (single client, robust) ====================
# Recommended: set MONGO_URI in environment or Codespaces secrets
MONGO_URI = os.environ.get("MONGO_URI")

# If you absolutely need a local fallback for quick testing, uncomment and edit below.
# WARNING: do NOT commit credentials in source code. Use a .env file or repo secrets instead.
# MONGO_URI = MONGO_URI or "mongodb+srv://<user>:<pass>@cluster0.example.mongodb.net/?retryWrites=true&w=majority"

def connect_mongo(uri, retries=2, timeout_ms=5000):
    if not uri:
        print("‚ö†Ô∏è  MONGO_URI not set. Set the MONGO_URI environment variable or use a .env file.")
        return None
    for attempt in range(1, retries + 2):
        try:
            client = MongoClient(uri, serverSelectionTimeoutMS=timeout_ms)
            client.admin.command("ping")
            print("‚úÖ CAN PING CLUSTER")
            try:
                dbs = client.list_database_names()
                print("Databases visible to client:", dbs)
            except Exception:
                # non-fatal: listing DBs may be restricted
                pass
            return client
        except Exception as e:
            print(f"‚ùå Mongo connect attempt {attempt} failed: {e}")
            traceback.print_exc(limit=1)
            if attempt <= retries:
                import time
                time.sleep(2)
    return None

mongo_client = connect_mongo(MONGO_URI)

# DB handles (may be None if connection failed)
student_db = None

# --- Backwards-compatible collection variables (created from student_db/chat_db) ---
# This allows older code that expects `users_collection`, `groups_collection`, etc. to keep working.
try:
    if student_db is not None:
        users_collection = student_db["users"]
        groups_collection = student_db["groups"]
        posts_collection = student_db["posts"]
        questions_collection = student_db["questions"]
        discussions_collection = student_db["discussions"]
    else:
        users_collection = groups_collection = posts_collection = questions_collection = discussions_collection = None
except Exception:
    users_collection = groups_collection = posts_collection = questions_collection = discussions_collection = None

try:
    if chat_db is not None:
        chats_collection = chat_db["chats"]
    else:
        chats_collection = None
except Exception:
    chats_collection = None
# --------------------------------------------------------
chat_db = None

if mongo_client:
    try:
        student_db = mongo_client["student_network_db"]
        chat_db = mongo_client["chat_db"]

        # Print collections (best-effort)
        try:
            print("\n   Database: student_network_db")
            print("   Collections:", student_db.list_collection_names())
        except Exception as e:
            print("   Could not list student_network_db collections:", e)

        try:
            print("\n   Database: chat_db")
            print("   Collections:", chat_db.list_collection_names())
        except Exception as e:
            print("   Could not list chat_db collections:", e)

        print("")  # spacer
    except Exception as e:
        print("‚ùå Error while creating DB handles:", e)
        traceback.print_exc(limit=1)
else:
    print("‚ùå Could not create Mongo client. DB handles are None. Routes using DB will return errors accordingly.")

# Helper collections (safe accessors)
def get_collection_safe(db, name):
    if db is None:
        raise RuntimeError(f"DB handle is not available for collection {name}")
    return db[name]

# ==================== UTILITIES ====================
def hash_password(password: str) -> bytes:
    """Hash password using bcrypt (returns bytes)."""
    return bcrypt.hashpw(password.encode("utf-8"), bcrypt.gensalt())

def check_password(password: str, pw_hash: bytes) -> bool:
    try:
        return bcrypt.checkpw(password.encode("utf-8"), pw_hash)
    except Exception:
        return False

# ==================== HTML ROUTES ====================
@app.route('/')
def index():
    return send_from_directory('.', 'frontpage.html')

@app.route('/<path:filename>')
def serve_file(filename):
    return send_from_directory('.', filename)

# ==================== DB-DEPENDENT ROUTES (use safe access) ====================

@app.route('/signup', methods=['POST'])
def signup():
    try:
        users_collection = get_collection_safe(student_db, "users")
        data = request.get_json() or {}
        email = data.get('email')
        password = data.get('password')
        fullName = data.get('fullName')
        university = data.get('university')
        branch = data.get('branch')
        academicYear = data.get('academicYear')
        skills = data.get('skills', [])

        if not (email and password and fullName and university and branch and academicYear):
            return jsonify({'error': 'All fields except skills are required'}), 400

        if users_collection.find_one({'email': email}):
            return jsonify({'error': 'User already exists'}), 409

        pw_hash = hash_password(password)

        user = {
            'email': email,
            'password': pw_hash,           # stored as bytes
            'fullName': fullName,
            'university': university,
            'branch': branch,
            'academicYear': academicYear,
            'skills': skills,
            'profilePhotoUrl': '',
            'coverPhotoUrl': '',
            'bio': 'Passionate student focused on learning and building innovative projects.',
            'createdAt': datetime.utcnow()
        }

        result = users_collection.insert_one(user)
        print(f"‚úÖ User created: {email} | ID: {result.inserted_id}")

        return jsonify({
            'success': True,
            'message': 'Account created successfully!',
            'user': {
                'id': str(result.inserted_id),
                'email': email,
                'fullName': fullName,
                'university': university,
                'branch': branch,
                'academicYear': academicYear,
                'skills': skills,
                'profilePhotoUrl': '',
                'coverPhotoUrl': '',
                'bio': user['bio']
            }
        }), 200
    except RuntimeError as re:
        print(f"‚ùå Signup runtime error (DB unavailable): {re}")
        return jsonify({'error': 'Database is unavailable'}), 503
    except Exception as e:
        print(f"‚ùå Signup error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({'error': 'Failed to create account'}), 500

@app.route("/login", methods=["POST"])
def login_api():
    try:
        users_collection = get_collection_safe(student_db, "users")
        data = request.get_json() or {}
        email = data.get('email')
        password = data.get('password')

        if not email or not password:
            return jsonify({'error': 'Email and password required'}), 400

        user = users_collection.find_one({"email": email})

        if not user:
            return jsonify({'error': 'User not found'}), 404

        if not check_password(password, user['password']):
            return jsonify({'error': 'Incorrect password'}), 401

        user_data = {
            "id": str(user.get('_id', '')),
            "email": user.get('email', ''),
            "fullName": user.get('fullName', ''),
            "university": user.get('university', ''),
            "branch": user.get('branch', ''),
            "academicYear": user.get('academicYear', ''),
            "skills": user.get('skills', []),
            "profilePhotoUrl": user.get('profilePhotoUrl', ''),
            "coverPhotoUrl": user.get('coverPhotoUrl', ''),
            "bio": user.get('bio', '')
        }

        print(f"‚úÖ User logged in: {email}")
        return jsonify({'success': True, 'user': user_data}), 200
    except RuntimeError as re:
        print(f"‚ùå Login runtime error (DB unavailable): {re}")
        return jsonify({'error': 'Database is unavailable'}), 503
    except Exception as e:
        print(f"‚ùå Login error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({'error': 'Login failed'}), 500

# --- Profile & utility routes (using safe collections) ---
@app.route("/updateprofile", methods=["POST"])
def update_profile():
    try:
        users_collection = get_collection_safe(student_db, "users")
        data = request.get_json() or {}
        user_id = data.get("userId")
        if not user_id:
            return jsonify({"error": "User ID required"}), 400

        update_data = {k: data[k] for k in ['fullName', 'bio', 'profilePhotoUrl', 'coverPhotoUrl', 'skills'] if k in data}

        result = users_collection.update_one({"_id": ObjectId(user_id)}, {"$set": update_data})
        if result.matched_count > 0:
            print(f"‚úÖ Profile updated: {user_id}")
            return jsonify({"success": True}), 200
        else:
            return jsonify({"error": "User not found"}), 404
    except RuntimeError as re:
        print(f"‚ùå Update profile runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database is unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Update profile error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": "Failed to update"}), 500

@app.route("/getuser/<user_id>", methods=["GET"])
def get_user(user_id):
    try:
        users_collection = get_collection_safe(student_db, "users")
        print(f"üîç Attempting to fetch user: {user_id}")

        user = None
        try:
            user = users_collection.find_one({"_id": ObjectId(user_id)})
            if user:
                print(f"‚úÖ Found user by ObjectId")
        except Exception:
            pass

        if not user:
            try:
                user = users_collection.find_one({"_id": user_id})
                if user:
                    print(f"‚úÖ Found user by string _id")
            except Exception:
                pass

        if not user:
            user = users_collection.find_one({"id": user_id})
            if user:
                print(f"‚úÖ Found user by id field")

        if not user:
            print(f"‚ùå User not found: {user_id}")
            return jsonify({"success": False, "error": "User not found"}), 404

        user_data = {
            "id": str(user.get('_id', user.get('id', user_id))),
            "email": user.get('email', ''),
            "fullName": user.get('fullName', ''),
            "university": user.get('university', ''),
            "branch": user.get('branch', ''),
            "academicYear": user.get('academicYear', ''),
            "skills": user.get('skills', []),
            "profilePhotoUrl": user.get('profilePhotoUrl', ''),
            "coverPhotoUrl": user.get('coverPhotoUrl', ''),
            "bio": user.get('bio', '')
        }

        print(f"‚úÖ Retrieved user: {user_data['fullName']} (ID: {user_data['id']})")
        return jsonify({"success": True, "user": user_data}), 200
    except RuntimeError as re:
        print(f"‚ùå Get user runtime error (DB unavailable): {re}")
        return jsonify({"success": False, "error": "Database is unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Get user error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"success": False, "error": f"Failed to get user: {str(e)}"}), 500

# ==================== GROUPS, POSTS, Q&A, DISCUSSIONS, CHAT ====================
# For brevity these handlers reuse the same pattern: obtain collections via get_collection_safe(...)
# and wrap actions with try/except. The logic is kept identical to your original functions.

# GROUP ROUTES
@app.route('/getavailablegroups', methods=['GET', 'POST'])

def get_groups():
    try:
        # use local import to guarantee the name is the regex module
        import re

        # determine user id from POST json or query param
        if request.method == 'POST' and request.is_json:
            data = request.get_json() or {}
            userid = str(data.get('userId', ''))
        else:
            userid = str(request.args.get('userId', ''))

        # fetch groups (sorted) and build response
        groups = list(groups_collection.find().sort('createdAt', -1))
        groupslist = []
        for group in groups:
            members = group.get('members', []) or []
            members = [str(m) for m in members]

            # tolerant lookup for preferred team size (several possible keys/formats)
            preferredteamsize = (
                group.get('preferred_team_size')
                or group.get('preferredteamsize')
                or group.get('preferred_teamSize')
                or group.get('preferred_team-size')
                or None
            )

            maxsize = None
            if preferredteamsize:
                # extract first integer if present, else try to parse as int
                try:
                    m = re.search(r'(\d+)', str(preferredteamsize))
                    if m:
                        maxsize = int(m.group(1))
                    else:
                        maxsize = int(str(preferredteamsize).strip())
                except Exception:
                    maxsize = None

            isfull = False
            if maxsize and len(members) >= maxsize:
                isfull = True

            ismember = userid in members if userid else False
            projectname = group.get('project_name') or group.get('projectName') or "Unnamed Group"
            if not str(projectname).strip():
                projectname = "Unnamed Group"

            groupslist.append({
                "groupId": str(group.get('_id')),
                "creatoruserid": str(group.get('creatoruserid')),
                "members": members,
                "memberCount": len(members),
                "maxMembers": maxsize,
                "isFull": isfull,
                "isMember": ismember,
                "preferredteamsize": preferredteamsize,
                "projectname": projectname,
                "descriptionobjective": group.get('description_objective', ""),
                "projecttimeline": group.get('project_timeline', ""),
                "requiredskills": group.get('required_skills', []),
                "createdAt": str(group.get('createdAt', datetime.utcnow()).isoformat())
            })

        return jsonify(success=True, groups=groupslist), 200

    except Exception as e:
        import traceback
        traceback.print_exc(limit=1)
        return jsonify(error="Could not load groups", details=str(e)), 500

@app.route("/creategroup", methods=["POST"])
def create_group():
    try:
        groups_collection = get_collection_safe(student_db, "groups")
        data = request.get_json()
        if not data.get("project_name"):
            return jsonify({"error": "Project name required"}), 400

        creator_id = str(data.get("creatoruserid"))
        group = {
            "creatoruserid": creator_id,
            "project_name": data.get("project_name"),
            "description_objective": data.get("description_objective", ""),
            "preferred_team_size": data.get("preferred_team_size", ""),
            "required_skills": data.get("required_skills", []),
            "project_timeline": data.get("project_timeline", ""),
            "members": [creator_id],
            "createdAt": datetime.utcnow()
        }
        result = groups_collection.insert_one(group)
        print(f"‚úÖ Group created: {group['project_name']} | ID: {result.inserted_id}")
        return jsonify({"success": True, "message": "Group created successfully!", "groupId": str(result.inserted_id)}), 200
    except RuntimeError as re:
        print(f"‚ùå Create group runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Create group error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": "Failed to create group"}), 500

@app.route("/joingroup", methods=["POST"])
def join_group_api():
    try:
        groups_collection = get_collection_safe(student_db, "groups")
        data = request.get_json()
        user_id = str(data.get("user_id"))
        group_id = data.get("group_id")

        if not user_id or not group_id:
            return jsonify({"error": "User ID and Group ID required"}), 400

        print(f"üîç Join group - User: {user_id}, Group: {group_id}")

        group = groups_collection.find_one({"_id": ObjectId(group_id)})
        if not group:
            print(f"‚ùå Group not found: {group_id}")
            return jsonify({"error": "Group not found"}), 404

        result = groups_collection.update_one({"_id": ObjectId(group_id)}, {"$addToSet": {"members": str(user_id)}})
        if result.matched_count > 0:
            print(f"‚úÖ User {user_id} joined group {group_id}")
            return jsonify({"success": True, "message": "Joined successfully!"}), 200
        else:
            return jsonify({"error": "Group not found"}), 404
    except RuntimeError as re:
        print(f"‚ùå Join group runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Join group error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": f"Failed to join group: {str(e)}"}), 500

@app.route("/leavegroup", methods=["POST"])
def leave_group_api():
    try:
        groups_collection = get_collection_safe(student_db, "groups")
        data = request.get_json()
        user_id = str(data.get("user_id"))
        group_id = data.get("group_id")

        if not user_id or not group_id:
            return jsonify({"error": "User ID and Group ID required"}), 400

        print(f"üîç Leave group - User: {user_id}, Group: {group_id}")

        group = groups_collection.find_one({"_id": ObjectId(group_id)})
        if not group:
            return jsonify({"error": "Group not found"}), 404

        result = groups_collection.update_one({"_id": ObjectId(group_id)}, {"$pull": {"members": str(user_id)}})
        if result.matched_count > 0:
            print(f"‚úÖ User {user_id} left group {group_id}")
            return jsonify({"success": True, "message": "Left group successfully!"}), 200
        else:
            return jsonify({"error": "Group not found"}), 404
    except RuntimeError as re:
        print(f"‚ùå Leave group runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Leave group error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": f"Failed to leave group: {str(e)}"}), 500

@app.route("/getmygroups", methods=["GET"])
def get_my_groups():
    try:
        groups_collection = get_collection_safe(student_db, "groups")
        user_id = str(request.args.get('userId'))
        if not user_id or user_id == 'None':
            return jsonify({"error": "User ID required"}), 400

        my_groups = list(groups_collection.find({'members': user_id}, {'_id': 1, 'project_name': 1}))
        groups_list = [{"groupId": str(g['_id']), "groupName": g.get("project_name", "Unnamed Group")} for g in my_groups]
        print(f"‚úÖ Retrieved {len(groups_list)} groups for user {user_id}")
        return jsonify({"success": True, "groups": groups_list}), 200
    except RuntimeError as re:
        print(f"‚ùå Get my groups runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Get my groups error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": "Could not load user's groups"}), 500

# POSTS
@app.route("/createpost", methods=["POST"])
def create_post():
    try:
        posts_collection = get_collection_safe(student_db, "posts")
        data = request.get_json()
        post = {
            "userId": data.get("userId"),
            "userName": data.get("userName"),
            "userPhoto": data.get("userPhoto", ""),
            "content": data.get("content", ""),
            "imageUrl": data.get("imageUrl", ""),
            "likes": [],
            "comments": [],
            "createdAt": datetime.utcnow()
        }
        result = posts_collection.insert_one(post)
        print(f"‚úÖ Post created by: {post['userName']} | ID: {result.inserted_id}")
        return jsonify({"success": True, "message": "Post created successfully!", "postId": str(result.inserted_id)}), 200
    except RuntimeError as re:
        print(f"‚ùå Create post runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Create post error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": "Failed to create post"}), 500

@app.route("/getposts", methods=["GET"])
def get_posts():
    try:
        posts_collection = get_collection_safe(student_db, "posts")
        posts = list(posts_collection.find({}).sort("createdAt", -1).limit(50))
        posts_list = [{
            "postId": str(p['_id']),
            "userId": p.get("userId"),
            "userName": p.get("userName"),
            "userPhoto": p.get("userPhoto", ""),
            "content": p.get("content", ""),
            "imageUrl": p.get("imageUrl", ""),
            "likes": p.get("likes", []),
            "comments": p.get("comments", []),
            "createdAt": p.get("createdAt", datetime.utcnow()).isoformat()
        } for p in posts]
        print(f"‚úÖ Retrieved {len(posts_list)} posts")
        return jsonify({"success": True, "posts": posts_list}), 200
    except RuntimeError as re:
        print(f"‚ùå Get posts runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Get posts error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": "Could not load posts"}), 500

# Q&A ROUTES (kept similar to your original logic)
@app.route("/createquestion", methods=["POST"])
def create_question():
    try:
        questions_collection = get_collection_safe(student_db, "questions")
        data = request.get_json() or {}
        if not data.get("title") or len(data.get("title", "").strip()) < 10:
            return jsonify({"error": "Question title must be at least 10 characters"}), 400

        question = {
            "userId": str(data.get("userId")),
            "userName": data.get("userName"),
            "userPhoto": data.get("userPhoto", ""),
            "title": data.get("title").strip(),
            "content": data.get("content", "").strip(),
            "tags": data.get("tags", []),
            "answers": [],
            "votes": 0,
            "views": 0,
            "createdAt": datetime.utcnow()
        }
        result = questions_collection.insert_one(question)
        print(f"‚úÖ Question created: {question['title'][:50]}... | ID: {result.inserted_id}")
        return jsonify({"success": True, "message": "Question posted successfully!", "questionId": str(result.inserted_id)}), 200
    except RuntimeError as re:
        print(f"‚ùå Create question runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Create question error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": f"Failed to create question: {str(e)}"}), 500

@app.route("/getquestions", methods=["GET"])
def get_questions():
    try:
        questions_collection = get_collection_safe(student_db, "questions")
        filter_type = request.args.get('filter', 'all').lower()
        search = request.args.get('search', '').strip()
        page = max(1, int(request.args.get('page', 1)))
        limit = min(100, max(1, int(request.args.get('limit', 5))))
        skip = (page - 1) * limit

        print(f"üì• GET /getquestions - filter: {filter_type}, search: '{search}', page: {page}, limit: {limit}")

        query = {}
        if search:
            search_term = search.replace('#', '').strip()
            query['$or'] = [
                {'title': {'$regex': search_term, '$options': 'i'}},
                {'content': {'$regex': search_term, '$options': 'i'}},
                {'tags': {'$in': [search_term.lower()]}}
            ]
        if filter_type == 'unanswered':
            query['$or'] = [{'answers': {'$exists': False}}, {'answers': {'$size': 0}}]

        if filter_type == 'most-voted':
            sort_field, sort_direction = "votes", -1
        elif filter_type == 'recent':
            sort_field, sort_direction = "createdAt", -1
        else:
            sort_field, sort_direction = "createdAt", -1

        cursor = questions_collection.find(query).sort(sort_field, sort_direction).skip(skip).limit(limit)
        questions = list(cursor)
        total_count = questions_collection.count_documents(query)

        questions_list = []
        for q in questions:
            formatted_answers = []
            for answer in q.get('answers', []):
                formatted_answers.append({
                    'answerId': answer.get('answerId', str(ObjectId())),
                    'userId': str(answer.get('userId', '')),
                    'userName': answer.get('userName', 'Anonymous'),
                    'userPhoto': answer.get('userPhoto', ''),
                    'content': answer.get('content', ''),
                    'votes': int(answer.get('votes', 0)),
                    'accepted': bool(answer.get('accepted', False)),
                    'createdAt': answer.get('createdAt', datetime.utcnow().isoformat())
                })
            questions_list.append({
                "questionId": str(q['_id']),
                "userId": str(q.get("userId", '')),
                "userName": q.get("userName", 'Anonymous'),
                "userPhoto": q.get("userPhoto", ""),
                "title": q.get("title", "Untitled Question"),
                "content": q.get("content", ""),
                "tags": q.get("tags", []),
                "answers": formatted_answers,
                "votes": int(q.get("votes", 0)),
                "views": int(q.get("views", 0)),
                "createdAt": q.get("createdAt", datetime.utcnow()).isoformat()
            })

        total_pages = (total_count + limit - 1) // limit if total_count > 0 else 1
        print(f"‚úÖ Retrieved {len(questions_list)} questions (Page {page}/{total_pages})")

        return jsonify({
            "success": True,
            "questions": questions_list,
            "pagination": {
                "currentPage": page,
                "totalPages": total_pages,
                "totalItems": total_count,
                "itemsPerPage": limit
            }
        }), 200
    except RuntimeError as re:
        print(f"‚ùå Get questions runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Get questions error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"success": False, "error": f"Could not load questions: {str(e)}"}), 500

@app.route("/addanswer", methods=["POST"])
def add_answer():
    try:
        questions_collection = get_collection_safe(student_db, "questions")
        data = request.get_json()
        question_id = data.get("questionId")
        content = data.get("content", "").strip()

        if not question_id:
            return jsonify({"error": "Question ID required"}), 400
        if not content or len(content) < 5:
            return jsonify({"error": "Answer must be at least 5 characters"}), 400

        answer = {
            "answerId": str(ObjectId()),
            "userId": str(data.get("userId")),
            "userName": data.get("userName", "Anonymous"),
            "userPhoto": data.get("userPhoto", ""),
            "content": content,
            "votes": 0,
            "accepted": False,
            "createdAt": datetime.utcnow().isoformat()
        }

        result = questions_collection.update_one({"_id": ObjectId(question_id)}, {"$push": {"answers": answer}})
        if result.matched_count > 0:
            print(f"‚úÖ Answer added to question {question_id}")
            return jsonify({"success": True, "message": "Answer posted!"}), 200
        else:
            return jsonify({"error": "Question not found"}), 404
    except RuntimeError as re:
        print(f"‚ùå Add answer runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Add answer error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": f"Failed to add answer: {str(e)}"}), 500

@app.route("/votequestion", methods=["POST"])
def vote_question():
    try:
        questions_collection = get_collection_safe(student_db, "questions")
        data = request.get_json()
        question_id = data.get("questionId")
        vote_type = data.get("voteType")

        if not question_id or not vote_type:
            return jsonify({"error": "Question ID and vote type required"}), 400

        increment = 1 if vote_type == "up" else -1
        result = questions_collection.update_one({"_id": ObjectId(question_id)}, {"$inc": {"votes": increment}})
        if result.matched_count > 0:
            print(f"‚úÖ Vote recorded for question {question_id}: {vote_type}")
            return jsonify({"success": True}), 200
        else:
            return jsonify({"error": "Question not found"}), 404
    except RuntimeError as re:
        print(f"‚ùå Vote question runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Vote question error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": "Failed to vote"}), 500

@app.route("/acceptanswer", methods=["POST"])
def accept_answer():
    try:
        questions_collection = get_collection_safe(student_db, "questions")
        data = request.get_json()
        question_id = data.get("questionId")
        answer_id = data.get("answerId")
        user_id = str(data.get("userId"))

        if not all([question_id, answer_id, user_id]):
            return jsonify({"error": "Question ID, Answer ID, and User ID required"}), 400

        q_obj = ObjectId(question_id)
        question = questions_collection.find_one({"_id": q_obj})
        if not question:
            return jsonify({"error": "Question not found"}), 404

        if str(question.get("userId")) != user_id:
            return jsonify({"error": "Unauthorized: You can only accept answers for your questions"}), 403

        questions_collection.update_one({"_id": q_obj}, {"$set": {"answers.$[].accepted": False}})
        result = questions_collection.update_one({"_id": q_obj, "answers.answerId": answer_id}, {"$set": {"answers.$.accepted": True}})
        if result.matched_count > 0:
            print(f"‚úÖ Answer {answer_id} accepted for question {question_id}")
            return jsonify({"success": True, "message": "Answer accepted!"}), 200
        else:
            return jsonify({"error": "Answer not found"}), 404
    except RuntimeError as re:
        print(f"‚ùå Accept answer runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Accept answer error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": f"Failed to accept answer: {str(e)}"}), 500

@app.route("/voteanswer", methods=["POST"])
def vote_answer():
    try:
        questions_collection = get_collection_safe(student_db, "questions")
        data = request.get_json()
        question_id = data.get("questionId")
        answer_id = data.get("answerId")
        vote_type = data.get("voteType")

        if not all([question_id, answer_id, vote_type]):
            return jsonify({"error": "Question ID, Answer ID, and vote type required"}), 400
        if vote_type not in ['up', 'down']:
            return jsonify({"error": "Vote type must be 'up' or 'down'"}), 400

        q_obj = ObjectId(question_id)
        inc = 1 if vote_type == 'up' else -1
        result = questions_collection.update_one({"_id": q_obj, "answers.answerId": answer_id}, {"$inc": {"answers.$.votes": inc}})
        if result.matched_count > 0:
            print(f"‚úÖ Answer {answer_id} voted {vote_type}")
            return jsonify({"success": True, "message": f"Answer {vote_type}voted!"}), 200
        else:
            return jsonify({"error": "Answer not found"}), 404
    except RuntimeError as re:
        print(f"‚ùå Vote answer runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Vote answer error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": f"Failed to vote on answer: {str(e)}"}), 500

# NOTIFICATIONS
@app.route('/getnotifications', methods=['GET'])
def get_notifications():
    try:
        groups_collection = get_collection_safe(student_db, "groups")
        user_id = str(request.args.get('userId'))
        if not user_id:
            return jsonify({'success': False, 'error': 'User ID required'}), 400

        notifications_data = []
        user_groups = list(groups_collection.find({'members': user_id}))

        for group in user_groups:
            group_id = str(group["_id"])
            project_name = group.get('project_name', 'Unnamed Group')
            created_at = group.get('createdAt', datetime.utcnow()).isoformat()
            notifications_data.append({
                'id': f'group-{group_id}',
                'type': 'group',
                'name': project_name,
                'avatar': project_name[0:2].upper() if project_name else 'UG',
                'time': created_at,
                'content': f"You joined the group '{project_name}'. Start collaborating!",
                'unread': True,
                'actionUrl': f"mainpage.html#group-{group_id}",
                'createdAt': created_at,
            })
            if str(group.get('creatoruserid')) == user_id and len(group.get('members', [])) > 1:
                member_count = len(group.get('members', []))
                notifications_data.append({
                    'id': f'member-{group_id}',
                    'type': 'activity',
                    'name': 'New Member Alert',
                    'avatar': 'üë•',
                    'time': created_at,
                    'content': f"Your group '{project_name}' now has {member_count} member{'s' if member_count > 1 else ''}!",
                    'unread': True,
                    'actionUrl': f"mainpage.html#group-{group_id}",
                    'createdAt': created_at,
                })

        notifications_data.append({
            'id': 'system-qa-update',
            'type': 'activity',
            'name': 'Platform Update',
            'avatar': 'üéâ',
            'time': datetime.utcnow().isoformat(),
            'content': 'New Q&A features are now live! Try asking your first question.',
            'unread': True,
            'actionUrl': 'qa.html',
            'createdAt': datetime.utcnow().isoformat(),
        })

        print(f"‚úÖ Generated {len(notifications_data)} notifications for user {user_id}")
        return jsonify({'success': True, 'notifications': notifications_data}), 200
    except RuntimeError as re:
        print(f"‚ùå Get notifications runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Get notifications error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({'success': False, 'error': str(e)}), 500

# DISCUSSIONS (kept same logic)
@app.route("/getdiscussions", methods=["GET"])
def get_discussions():
    try:
        discussions_collection = get_collection_safe(student_db, "discussions")
        groups_collection = get_collection_safe(student_db, "groups")
        user_id = str(request.args.get('userId'))
        if not user_id or user_id == 'None':
            return jsonify({"error": "User ID required"}), 400

        user_groups = list(groups_collection.find({'members': user_id}, {'_id': 1}))
        group_ids = [str(g['_id']) for g in user_groups]

        discussions = list(discussions_collection.find({'groupId': {'$in': group_ids}}).sort("lastMessageTime", -1).limit(50))
        discussions_list = []
        for d in discussions:
            discussions_list.append({
                "discussionId": str(d['_id']),
                "roomName": d.get("roomName"),
                "topic": d.get("topic", ""),
                "participants": d.get("participants", []),
                "lastMessage": d.get("lastMessage", ""),
                "lastMessageTime": d.get("lastMessageTime", datetime.utcnow()).isoformat(),
                "createdBy": d.get("createdBy"),
                "createdByName": d.get("createdByName", ""),
                "groupId": d.get("groupId"),
                "groupName": d.get("groupName", ""),
                "createdAt": d.get("createdAt", datetime.utcnow()).isoformat()
            })
        print(f"‚úÖ Retrieved {len(discussions_list)} discussions for user {user_id}")
        return jsonify({"success": True, "discussions": discussions_list}), 200
    except RuntimeError as re:
        print(f"‚ùå Get discussions runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Get discussions error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": str(e)}), 500

@app.route("/creatediscussion", methods=["POST"])
def create_discussion():
    try:
        discussions_collection = get_collection_safe(student_db, "discussions")
        groups_collection = get_collection_safe(student_db, "groups")
        data = request.get_json()
        room_name = data.get("roomName")
        group_id = data.get("groupId")
        user_id = str(data.get("userId"))
        if not all([room_name, group_id, user_id]):
            return jsonify({"error": "Room name, group ID, and user ID required"}), 400

        group = groups_collection.find_one({"_id": ObjectId(group_id)})
        if not group:
            return jsonify({"error": "Group not found"}), 404

        members = [str(m) for m in group.get("members", [])]
        if user_id not in members:
            return jsonify({"error": "You are not a member of this group"}), 403

        discussion = {
            "roomName": room_name,
            "topic": data.get("topic", ""),
            "createdBy": user_id,
            "createdByName": data.get("userName"),
            "participants": [user_id],
            "messages": [],
            "lastMessage": "",
            "lastMessageTime": datetime.utcnow(),
            "createdAt": datetime.utcnow(),
            "groupId": group_id,
            "groupName": group.get("project_name", "")
        }
        result = discussions_collection.insert_one(discussion)
        print(f"‚úÖ Discussion created: {discussion['roomName']} | ID: {result.inserted_id}")
        return jsonify({"success": True, "message": "Discussion created!", "discussionId": str(result.inserted_id)}), 200
    except RuntimeError as re:
        print(f"‚ùå Create discussion runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Create discussion error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": str(e)}), 500

@app.route("/getmessages/<discussion_id>", methods=["GET"])
def get_messages(discussion_id):
    try:
        discussions_collection = get_collection_safe(student_db, "discussions")
        groups_collection = get_collection_safe(student_db, "groups")
        user_id = str(request.args.get('userId'))
        if not user_id or user_id == 'None':
            return jsonify({"error": "User ID required"}), 400

        discussion = discussions_collection.find_one({"_id": ObjectId(discussion_id)})
        if not discussion:
            return jsonify({"error": "Discussion not found"}), 404

        group_id = discussion.get("groupId")
        if group_id:
            group = groups_collection.find_one({"_id": ObjectId(group_id)})
            if not group:
                return jsonify({"error": "Group not found"}), 403
            members = [str(m) for m in group.get("members", [])]
            if user_id not in members:
                return jsonify({"error": "Access denied"}), 403

        return jsonify({
            "success": True,
            "messages": discussion.get("messages", []),
            "roomName": discussion.get("roomName"),
            "topic": discussion.get("topic", ""),
            "groupName": discussion.get("groupName", "")
        }), 200
    except RuntimeError as re:
        print(f"‚ùå Get messages runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Get messages error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": str(e)}), 500

@app.route("/sendmessage", methods=["POST"])
def send_message():
    try:
        discussions_collection = get_collection_safe(student_db, "discussions")
        groups_collection = get_collection_safe(student_db, "groups")
        data = request.get_json()
        discussion_id = data.get("discussionId")
        user_id = str(data.get("userId"))
        if not discussion_id or not user_id:
            return jsonify({"error": "Discussion ID and User ID required"}), 400

        discussion = discussions_collection.find_one({"_id": ObjectId(discussion_id)})
        if not discussion:
            return jsonify({"error": "Discussion not found"}), 404

        group_id = discussion.get("groupId")
        if group_id:
            group = groups_collection.find_one({"_id": ObjectId(group_id)})
            if not group:
                return jsonify({"error": "Group not found"}), 403
            members = [str(m) for m in group.get("members", [])]
            if user_id not in members:
                return jsonify({"error": "Access denied"}), 403

        message = {
            "messageId": str(ObjectId()),
            "userId": user_id,
            "userName": data.get("userName"),
            "userPhoto": data.get("userPhoto", ""),
            "content": data.get("content"),
            "timestamp": datetime.utcnow().isoformat()
        }

        result = discussions_collection.update_one(
            {"_id": ObjectId(discussion_id)},
            {
                "$push": {"messages": message},
                "$set": {"lastMessage": data.get("content"), "lastMessageTime": datetime.utcnow()},
                "$addToSet": {"participants": user_id}
            }
        )
        if result.matched_count > 0:
            print(f"‚úÖ Message sent in discussion {discussion_id}")
            return jsonify({"success": True}), 200
        else:
            return jsonify({"error": "Discussion not found"}), 404
    except RuntimeError as re:
        print(f"‚ùå Send message runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Send message error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": str(e)}), 500

# CHAT ROUTES (use chat_db handle)
@app.route('/chat', methods=['POST'])
def save_chat():
    try:
        chats_collection = get_collection_safe(chat_db, "chats")
        data = request.get_json() or {}
        username = data.get('username')
        message = data.get('message')
        room = data.get('room', 'general')
        if not username or not message:
            return jsonify({"error": "Username and message required"}), 400

        chat = {"username": username, "message": message, "room": room, "timestamp": datetime.utcnow()}
        result = chats_collection.insert_one(chat)
        print(f"‚úÖ Chat saved: {username} in {room}")
        return jsonify({"success": True, "chatId": str(result.inserted_id)}), 201
    except RuntimeError as re:
        print(f"‚ùå Save chat runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Save chat error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": "Failed to save chat"}), 500

@app.route('/chats', methods=['GET'])
def get_chats():
    try:
        chats_collection = get_collection_safe(chat_db, "chats")
        room = request.args.get('room', None)
        query = {"room": room} if room else {}
        chats = list(chats_collection.find(query).sort("timestamp", -1).limit(100))
        for c in chats:
            c['_id'] = str(c['_id'])
            c['timestamp'] = c['timestamp'].isoformat() if 'timestamp' in c else None
        print(f"‚úÖ Retrieved {len(chats)} chats")
        return jsonify({"success": True, "chats": chats}), 200
    except RuntimeError as re:
        print(f"‚ùå Get chats runtime error (DB unavailable): {re}")
        return jsonify({"error": "Database unavailable"}), 503
    except Exception as e:
        print(f"‚ùå Get chats error: {e}")
        traceback.print_exc(limit=1)
        return jsonify({"error": "Failed to get chats"}), 500

# HEALTH & TEST
@app.route('/health', methods=['GET'])
def health():
    try:
        if mongo_client is None:
            db_status = "disconnected"
        else:
            mongo_client.admin.command('ping')
            db_status = "connected"
    except Exception:
        db_status = "disconnected"
    return jsonify({"status": "healthy", "database": db_status, "timestamp": datetime.utcnow().isoformat()}), 200

@app.route('/test', methods=['GET'])
def test():
    return jsonify({
        "message": "‚úÖ The Huddle API is working!",
        "databases": {
            "student_network_db": ["users", "groups", "posts", "questions", "discussions"],
            "chat_db": ["chats"]
        },
        "endpoints": {
            "auth": ["/signup [POST]", "/login [POST]"],
            "profile": ["/updateprofile [POST]", "/getuser/<user_id> [GET]"],
            "groups": ["/getavailablegroups [GET/POST]", "/creategroup [POST]", "/joingroup [POST]", "/leavegroup [POST]", "/getmygroups [GET]"],
            "posts": ["/createpost [POST]", "/getposts [GET]"],
            "qa": ["/createquestion [POST]", "/getquestions [GET]", "/addanswer [POST]", "/votequestion [POST]", "/acceptanswer [POST]", "/voteanswer [POST]"],
            "discussions": ["/getdiscussions [GET]", "/creatediscussion [POST]", "/getmessages/<id> [GET]", "/sendmessage [POST]"],
            "chat": ["/chat [POST]", "/chats [GET]"],
            "notifications": ["/getnotifications [GET]"],
            "utility": ["/health [GET]", "/test [GET]"]
        }
    }), 200

# ==================== START SERVER (dev only) ====================
if __name__ == "__main__":
    print("\    import re\nn" + "="*70)
    print("üöÄ THE HUDDLE - STUDENT NETWORKING PLATFORM")
    print("="*70)
    print(f"üåê Server URL:    http://127.0.0.1:5000")
    print(f"üóÑÔ∏è  Database 1:    student_network_db")
    print(f"üóÑÔ∏è  Database 2:    chat_db")
    print(f"‚úÖ Status:        Ready")
    print(f"üÜï Q&A Features:  Enhanced with better error handling")
    print("="*70)
    print("\nüìÑ Available Pages:")
    print("   ‚Ä¢ http://127.0.0.1:5000/login.html")
    print("   ‚Ä¢ http://127.0.0.1:5000/qa.html")
    print("\nüîß Test Endpoints:")
    print("   ‚Ä¢ http://127.0.0.1:5000/test")
    print("   ‚Ä¢ http://127.0.0.1:5000/health")
    print("   ‚Ä¢ http://127.0.0.1:5000/getquestions")
    print("="*70 + "\n")

    # For local development we keep debug on. In production (gunicorn) this block is skipped.
    app.run(host="127.0.0.1", port=5000, debug=True)